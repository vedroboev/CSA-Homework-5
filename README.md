# Домашнее задание по АВС №5

*Выполнил Абаев Федор, БПИ 203*

**Вариант 1 - Задача о парикмахере**

*Примечание - этот файл лучше смотреть напрямую на сайте гитхаба или через какой-нибудь редактор markdown.*

## Описание программы

Программа симулирует рабочий день парикмахерской. В ней есть один парикмахер, который, естественно, может стричь только
одного человека за раз. Пока никого в зале нет - парикмахер спит, когда приходит новый клиент, то он будит парикмахера и
тот его стрижет. Если клиент приходит и парикмахер занят стрижкой - то он встает в очередь и засыпает. Когда клиент
заканчивает стрижку, он провожает клиента, будит следующего клиента из очереди и стрижет его.

---

## Модель реализации

Для реализации программы использовалась модель **"Клиенты и серверы"** (кратко описана в файле с заданием). В данном
случае парикмахер у нас это *сервер*, который ждет, пока не придет клиент, а затем выполняет его запрос (стрижет его).
Клиент же, очевидно, является *клиентом*, и при приходе в парикмахерскую он ждет, пока парикмахер освободится, а затем
делает запрос на стрижку. Такой вариант достаточно очевидно следует из условия задачи и является очень удобным для ее
реализации. В моем случае парикмахер (сервер) работает постоянно, и постоянно ждет новых клиентов, а потоки клиентов
отрабатывают только один раз и в этот момент запрашивают стрижку у парикмахера.

### Замечания по реализации

+ Использую 4 мьютекса и 1 семафор, вот их описания:
    + Мьютекс `incrementing` использую для того, чтобы безопасно изменять данные о количестве пользователей в целом / в
      очереди. При его использовании данные измеряются в критической секции, он всегда сразу открывается после их
      изменения.
    + Мьютекс `busy` использую для того, чтобы показать то, что парикмахер занят. Пока он занят, другой клиент не может
      к нему обратиться.
    + Мьютекс `cutting` использую для того, чтобы показать, что парикмахер в данный момент занят стрижкой. Имеет немного
      другие функции по сравнению с `busy`, хотя они похожи. Например, с помощью этого мьютекса мы обеспечиваем то, что
      клиент покинет парикмахерскую только после того, как его стрижка закончится.
    + Мьютекс `leaving` использую для того, чтобы корректно обеспечить покидание салона клиентом. С помощью него
      обеспечиваем то, что парикмахер должен проводить клиента (дождаться, пока он покинет салон) перед тем, как
      начинать новую стрижку.
    + Семафор `customers_waiting` использую для подсчета клиента в очереди и обеспечении корректной с ней работой. Мы
      постим в него каждый раз, когда приходит новый клиент, и ждем (отнимаем 1) на него каждый раз, когда парикмахер
      готов сделать новую стрижку.
+ Изначально хотел делать задачу с использованием объектно-ориентированного подхода, но возникли проблемы с библиотекой
  POSIX и нестатическими методами и в целом программа сильно усложнилась, решил использовать процедурный подход.
+ Фактически говоря, *очереди* клиентов у меня нет - клиенты это просто некоторые абстрактные потоки без имени и
  характеристик, а корректную работу мы обеспечиваем, *считая* их. В этой реализации есть некоторые проблемы - например,
  нет гарантии, что парикмахер позовет следующего клиента из зала ожидания в порядке очереди. Можно было бы сделать
  более полноценную программу, привязав потоки к определенным объектам и воспользовавшись структурой очереди, но я решил
  выбрать более простой вариант.

---

## Формат ввода и вывода

#### Ввод

При запуске программы никаких аргументов указывать не надо, все запрашивается в консоли уже после ее запуска. Требуется
ввести три параметра - **длительность дня** (в секундах), **число покупателей за день** и **максимальную длительность
стрижки** (в секундах). В программе описано, в каких пределах они должны лежать. Время измеряю в секундах, потому что
мне показалось это разумным для данной задачи.

#### Вывод

Сообщения о работе программы выводятся на консоль во время ее работы (в течение рабочего дня). Для удобства чтения
пометил их тегами:

+ `[WAITING ROOM]` - Событие в комнате ожидания - пришел новый человек. Отображается номер этого человека, а так же
  число людей в комнате ожидания на момент его прихода.
+ `[BARBER]` - Событие от парикмахера. Выводится, когда он зовет нового клиента на стрижку / заканчивает стрижку. В
  первом случае выводится количество людей, оставшихся после этого в комнате ожидания, во втором случае выводится время,
  которое ушло у парикмахера на стрижку. В обоих случаях выводится номер клиента, которого стригут.
+ `[CUSTOMER]` - Событие от клиента. Не вывожу его в начале и в конце стрижки, чтобы избежать повторения вывода, однако
  вывожу его, когда клиент покидает салон. Это в частности помогает понять, действительно ли парикмахер полностью
  провожает клиента из салона.

По окончании рабочего дня выводится соответствующее сообщение и программа завершается.

### Замечания по работе программы

+ В моем случае программа симулирует ровно один рабочий день, который длится определенное количество секунд. Она
  заканчивается либо после того, как время рабочего дня истекло, либо после того, как пришли все клиенты на данный день.
+ Время ожидания между приходом новых пользователей, а так же время стрижки, определяются случайно. Верхнюю границу для
  времени стрижки задает пользователь, верхняя граница для интервала между клиентами определяется на основе длительности
  дня и их количества в этот день (эти два параметра тоже задает пользователь).
+ Ограничения в программе есть, но в основном нацелены на то, чтобы она работала разумное реальное время и была удобно
  читаема в консоли. Их можно снять, все должно работать нормально.
